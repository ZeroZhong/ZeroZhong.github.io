{"meta":{"title":"浩瀚星海","subtitle":null,"description":"less is more","author":"ZeroZhong","url":"http://www.zhongweimin.me","root":"/"},"pages":[],"posts":[{"title":"bean 生命周期","slug":"bean-生命周期","date":"2019-05-08T06:55:26.000Z","updated":"2019-05-08T07:56:20.870Z","comments":true,"path":"2019/05/08/bean-生命周期/","link":"","permalink":"http://www.zhongweimin.me/2019/05/08/bean-生命周期/","excerpt":"","text":"####asjdlkasjdlksad asdjlasjld ####adk;sd;lsa hello","categories":[],"tags":[]},{"title":"策略模式","slug":"策略模式","date":"2018-10-02T09:37:49.000Z","updated":"2019-05-08T09:38:53.548Z","comments":true,"path":"2018/10/02/策略模式/","link":"","permalink":"http://www.zhongweimin.me/2018/10/02/策略模式/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;class Strategy&#123; public: Strategy(); virtual ~Strategy(); virtual void algrithm() = 0;&#125;;Strategy::Strategy()&#123;&#125;Strategy::~Strategy()&#123;&#125;class Context&#123; public: Context(Strategy * strategy); ~Context(); void doAction(); private: Strategy * m_Strategy;&#125;;Context::Context(Strategy * strategy)&#123;m_Strategy = strategy;&#125;Context::~Context()&#123;&#125;void Context::doAction()&#123;m_Strategy-&gt;algrithm(); &#125;class StrategyA : public Strategy&#123; public: virtual void algrithm();&#125;;void StrategyA::algrithm()&#123; cout &lt;&lt; &quot;StrategyA algrithm&quot; &lt;&lt; endl;&#125;class StrategyB : public Strategy&#123; public: virtual void algrithm();&#125;;void StrategyB::algrithm()&#123; cout &lt;&lt; &quot;StrategyB algrithm&quot; &lt;&lt; endl;&#125;int main( int argc, char ** argv)&#123; Strategy *a = new StrategyA(); Strategy *b = new StrategyB(); Context * context = new Context(a); context-&gt;doAction(); delete context; delete a; delete b; return 0;&#125;","categories":[],"tags":[]},{"title":"Foxmail邮件部署","slug":"Foxmail邮件部署","date":"2018-10-02T09:29:11.000Z","updated":"2019-05-08T09:37:14.327Z","comments":true,"path":"2018/10/02/Foxmail邮件部署/","link":"","permalink":"http://www.zhongweimin.me/2018/10/02/Foxmail邮件部署/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"python入门","slug":"python入门","date":"2018-02-08T08:12:41.000Z","updated":"2019-05-08T08:13:16.736Z","comments":true,"path":"2018/02/08/python入门/","link":"","permalink":"http://www.zhongweimin.me/2018/02/08/python入门/","excerpt":"","text":"环境搭建 1.学习完整 Python官网：https://www.python.org/Python文档：https://www.python.org/doc/2.环境 window环境https://www.python.org/downloads/windows/Window平台安装包，包格式为：python-XYZ.msi 文件 ， XYZ 为你要安装的版本号","categories":[],"tags":[]},{"title":"linux用户命令","slug":"linux用户命令","date":"2017-12-07T08:11:46.000Z","updated":"2019-05-08T08:12:17.063Z","comments":true,"path":"2017/12/07/linux用户命令/","link":"","permalink":"http://www.zhongweimin.me/2017/12/07/linux用户命令/","excerpt":"","text":"useradd 建立一个新用户账户testuser1，并设置UID为544，主目录为/usr/testuser1，属于users组1 #useradd -u 544 -d /usr/testuser1 -g users -m testuser1(加-m 如果主目录不存在则自动创建) adduser 和 passwd 使用管理员账号登陆系统，建立用户tmp_3452 密码3sdt5:Eawhg 1 2 adduser tmp_3452passwd tmp_3452userdel删除用户 删除刚创建的账号 tmp_3452 1 userdel tmp_3452连同用户目录一并删除 1 userdel -f tmp_3452强制退出已经登陆用户 查看当前登陆用户 1 w强制退出命令pkill (命令原型： pkill -kill -t [TTY]) 1 pkill -kill -t ps1","categories":[],"tags":[]},{"title":"二叉树","slug":"二叉树","date":"2017-06-08T08:09:58.000Z","updated":"2019-05-08T08:11:14.063Z","comments":true,"path":"2017/06/08/二叉树/","link":"","permalink":"http://www.zhongweimin.me/2017/06/08/二叉树/","excerpt":"","text":"计算机：二叉树是每个节点最多有两个子树的树结构图论：二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根结点的度不大于2 #####1 五种形态 空二叉树只有一个根结点的二叉树只有左子树只有右子树完全二叉树 #####2 遍历遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。 设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先根次序遍历），LDR（称为中根次序遍历），LRD （称为后根次序遍历） 先序遍历首先访问根，再先序遍历左（右）子树，最后先序遍历右（左）子树中序遍历首先中序遍历左（右）子树，再访问根，最后中序遍历右（左）子树后序遍历首先后序遍历左（右）子树，再后序遍历右（左）子树，最后访问根层次遍历即按照层次访问。访问根，访问子女，再访问子女的子女 #####3 性质 一个二叉树第i 层的最大结点数为：2i-1，i ≥ 1深度为k 的二叉树有最大结点总数为：2k-1，k ≥ 1对任何非空二叉树T，若n0 表示叶结点的个数，n2 是度为2 的非叶结点个数，那么两者满足关系n0 = n2 + 1 #####4 程序描述 数据来源括号表示法，以及类似表示方法 类型 typedef struct BTNode BinaryTree;typedef char ElementType;typedef struct Node{ ElementType data; struct Node left; struct Node * right;} BTNode;函数 BinaryTree InitBinaryTree()：创建一个二叉树，通过某个方式构建二叉树boolean IsEmpty(BinaryTree tree)：判别BT 是否为空BTNode InsertNode(BTNode parent, BTNode * new，int position) ：插入新节点（0，左；1，右）void Traversal(BinaryTree tree)：遍历，按某顺序访问每个结点void PreOrder(BinaryTree tree)：先序——根、左子树、右子树void InOrder(BinaryTree tree)：中序——左子树、根、右子树void PostOrder(BinaryTree tree)：后序——左子树、右子树、根void HierarchyOrder(BinaryTree tree)：层次遍历——从上到下void Print(BinaryTree tree)：打印二叉树void Destroy(BinaryTree tree)：销毁二叉树其他操作 BTNode * Search(BinaryTree tree,ElementType x) ： 二叉树中查找元素链接:http://chuansong.me/n/729497552547百度百科","categories":[],"tags":[]},{"title":"树","slug":"树","date":"2017-06-08T08:09:00.000Z","updated":"2019-05-08T08:09:36.463Z","comments":true,"path":"2017/06/08/树/","link":"","permalink":"http://www.zhongweimin.me/2017/06/08/树/","excerpt":"","text":"####树的定义 树（Tree）：n（n ≥ 0）个结点构成的有限集合。 当n = 0 时，称为空树。对于任一颗非空树（n &gt; 0），它具备以下性质：树中有一个称为”根（Root）”的特殊结点，用r 表示；其余结点（与r 相关联的）可分为m（m &gt; 0）个互不相交的有限集T1，T2，…，Tm，其中每个集合本身又是一颗树，称为原来树的”子树（SubTree）”。树与非树？ 子树是不相交的除了根结点外，每个结点有且仅有一个父节点一颗N个结点的树有N-1条边（我认为可以用构造性的存在性证明或是数学归纳法来证明这一点） ####树的一些基本术语： 结点的度（Degree）：结点的子树个数树的度：树的所有结点中最大的度数叶结点（Leaf）：度为0的结点父结点（Parent）：有子树的结点是其子树的根结点的父结点子结点（Child）：若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也称孩子结点兄弟结点（Sibling）：具有同一父结点的各结点彼此是兄弟结点路径和路径长度（Path）：从结点n1到nk的路径为一个结点序列n1，n2，…，nk，ni是ni+1的父结点，路径所包含的边的个数为路径的长度祖先结点（Ancestor）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点子孙结点（Descendant）：某一结点的子树中的所有结点都是这个结点子孙结点的层次（Level）：规定根结点在1层，其它任一结点的层数时其父节点的层数加1树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度 ####树的表示 儿子-兄弟表示法括号表示法 ####树的算法实现 123456typedef char ElementType;typedef struct Node{ ElementType data; struct Node child; struct Node sibling;} TreeNode;链接:http://chuansong.me/n/729497552547","categories":[],"tags":[]},{"title":"Hexo-配置","slug":"Hexo-配置","date":"2017-06-05T08:05:48.000Z","updated":"2019-05-08T08:06:58.333Z","comments":true,"path":"2017/06/05/Hexo-配置/","link":"","permalink":"http://www.zhongweimin.me/2017/06/05/Hexo-配置/","excerpt":"","text":"git安装node环境安装hexo安装npm install hexo-cli -ghexo init #初始化hexonpm install #安装依赖包npm install hexo-deployer-git –save #安装hexo发布使用git配置_config.yml Hexo 最常用的几个命令hexo new “博客” 简写 hexo n “博客” #新建文章hexo publish 简写 hexo p #可以不使用用hexo generate 简写 hexo g #生成hexo server 简写 hexo s #启动服务预览hexo deploy 简写 hexo d #部署 文章内容title: 使用Hexo搭建个人博客date: 2017-06-05 02:20:06categories: Blogtags: [Hexo] 问题 不能添加图片[解决]把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为truehexo目录下执行npm install hexo-asset-image –save，(安装一个可以上传本地图片的插件) 此时运行hexo n “xxxx” 生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后在xxxx.md中按照markdown的格式引入图片 (注意:xxxx是这个md文件的名字，也是同名文件夹的名字。引用图片时,使用相对路径) 最后检查一下，hexo g生成页面后，进入public目录查看生成情况，然后使用hexo s 预览 出错重复上述步骤","categories":[],"tags":[]},{"title":"Git远程库操作","slug":"Git远程库操作","date":"2017-05-31T08:07:46.000Z","updated":"2019-05-08T08:08:33.403Z","comments":true,"path":"2017/05/31/Git远程库操作/","link":"","permalink":"http://www.zhongweimin.me/2017/05/31/Git远程库操作/","excerpt":"","text":"git remote git remote -v 管理主机名git remote show &lt;主机名&gt; 查看该主机的详细信息git remote add &lt;主机名&gt; &lt;网址&gt; 添加远程主机git remote rm &lt;主机名&gt; 删除远程主机git remote rename &lt;原主机名&gt; &lt;新主机名&gt; 远程主机的改名git fetch git fetch &lt;远程主机名&gt; 取回所有分支（branch）的更新git fetch &lt;远程主机名&gt; &lt;分支名&gt; 取回特定分支的更新git pull git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 取回远程主机某个分支的更新，再与本地的指定分支合并手动建立追踪关系 git branch –set-upstream master origin/testgit push git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;git push origin :remote_branch //删除远程分支（the_branch）git push origin local_branch //本地分支（local_branch）重新建立远程分支","categories":[],"tags":[]}]}